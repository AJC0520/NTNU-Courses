One of the biggest challenges is the concept of reliable data transfer.
![[Pasted image 20250319115209.png]]

Complexity of reliable data transfer protocol will depend (strongly) on characteristics of unrealiable channel (lose, corrupt, reorder data).

Sender, receiver do NOT know the "state" of each other. was a message received?
- Unless communicated via a message.

#### Reliable data transfer: getting started
We will:
- Incrementally develop sender, receiver sides of reliable data transfer protocol (rdt)
- consider only unidirectional data transfer
	- but control info will flow on both directions!
* use finite state machines (fsm) to specify sender, receiver

#### rdt1.0: reliable transfer over a reliable channel
- underlying channel perfectly reliable
	- no bit errors
	- no loss of packets
- seperate FSMs for sender, receiver
	- sender sends data into underlying channel
	- receiver reads data from underlying channel
 ![[Pasted image 20250319120203.png]]



#### rdt2.0: channel with bit errors
- Underlying channel may flip bits in packets
	- checksum to detect bit errors
- the question? how to recover from errors?
	- acknowledgemensts (ACKs) receiver explicity tells sender that pkt received ok
	- negative acknowledgements(NAKs) receiver explicitly tells sender that pkt had errors
	- sender retransmits pkt on receipt of NAK

stop and wait
sender sends one packet, then waits for receiver response

![[Pasted image 20250319121832.png]]
This has a fatal flaw!

What happens if ACK/NAK corrupted?
- sender doesnt know what happened at receiver!
- cant just retransmit: possible duplicate.

handling duplicates:
- sender retransmits current pkt if ACK/NAK corrupted
- sender adds sequence number to each pkt
- receiver discards (doesnt deliver up) duplicate pkt


#### rdt2.1: sender, handling garbled ACK/NAKs
![[Pasted image 20250319123003.png]]
![[Pasted image 20250319123017.png]]
Sender:
- Seq # added to pkt
- two seq. #s (0,1) will suffice. Why?
- must check if received ACK/NAK corrupted
- twice as many states,
	- state must "remember" wherher expected pkt should have seq # of 0 or 1

receiver:
- must check if received packet is dupliacte
	- state indicates whether 0 or 1 is expected pkt seq #
>[!NOTE]
>receiver can not know if its last ACK/NACK received OK at sender

#### rdr3.0 channels with errors and loss
Underlying channel can also lose packets.
Approach:
sender waits reasonable amount of time for ack
- retransmits if no ACK received in this time
- if pkt(or ACK) just delayed, not lost
	- Retransmission will ble duplicate, but seq #s already handles this!
	- receiver must specify seq # of packet being ACKed

![[Pasted image 20250321123133.png]]

Go-Back-N: sender
sender: window of up to N, consecutive transmitted but unACKed pkts
- k-bit seq # in pkt header

![[Pasted image 20250321125416.png]]
- cumulative ACK: ACK(n): ACKs all packets up to, including seq # n on receving ACK(n): move window forward to begin at n + 1
- timer for oldest in-flight packet
- timeout(n): retransmit packet n and all higher seq # paackets in window.

Go-Back-N receiver
- ACK-only: always send ACK for correctly-received packet so far, with highest in-order seq #s 
	- may generate duplicate ACKs
	- need only remember rcv_base
- on receipt of out-of-order packet:
	- can discard (dont buffer) or buffer: an implementation decision
	- re-ACK pkt with highest in-order seq #


#### Selective repeat
receiver individually acknowledges all correctly received packets
- buffers packets, as needed, for eventual in-order delivery to upper layer
sendet times-out/retransmits individually for unacked packets

![[Pasted image 20250321130948.png]]
 