#### User datagram protocol

"no frills", "bare bones" Internet transport protocol
"best effort" service: UDP segments may be lost or deliver out-of-order to app.

Connectionless: 
no handshaking between UDP sender, receiver
Each UDP segment handled independently of others

#### Why is there a UDP?
- No connection establishment (which can add RTT delay)
- Simple: no connection state at sender, receiver
- Small header size
- No congestion control
	- UDP can blast away as fast as desired!
	- can function in the face of congestion

##### UDP use:
- streaming multimedia apps (loss tolerant, rate sensitive)
- DNS
- SNMP
- HTTP/3

If reliable transfer need over UDP (e.g HTTP/3)
- add needed reliability at application layer
- add congestion control at application layer


##### UDP sender actions:
- Is passed an application-layer message
- Determines UDP segment header field values
- creates UDP segment
- passes segment to IP


#### UDP receiver segment
- receives segment from IP
- checks UDP checksum header value
- extracts application-layer message
- demultiplexes message up to application via socket

![[Pasted image 20250319111245.png]]

length, in bytes of UDP segment, including header
#### UDP checksum
Goal: detect error (flipped bits) in transmitted segment

example:
transmitted 4 and 6 and a sum 10
received 5 and 6 and a sum 10

sender:
- treat contents of UDP segment (including UDP header fields and IP addresses) as sequence of 16-bit integers.
- checksum: addition (ones complement sum) of segment content
- checksum value put into UDP checksum field.


receiver:
- compute checksum of received segment
- check if computed checksum equals checksum field value:
	- not equal: error detected
	- equal: no error detected, but maybe error nonetheless


#### Internet checksum: an example

add two 16-bits integers
![[Pasted image 20250319111900.png]]

![[Pasted image 20250319111958.png]]

Checksum is a form of protection, but not fool proof.



